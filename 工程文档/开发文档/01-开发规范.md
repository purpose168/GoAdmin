# GoAdmin 开发规范

## 文档信息

- **项目名称**: GoAdmin
- **文档版本**: v1.0
- **创建日期**: 2026-01-05
- **最后更新**: 2026-01-05
- **文档类型**: 开发规范

---

## 1. 代码规范

### 1.1 Go 语言规范

GoAdmin 遵循 Go 语言官方代码规范，同时制定了一些项目特定的规范。

#### 1.1.1 命名规范

**包命名**:
- 包名使用小写单词
- 不使用下划线或驼峰
- 包名应该简短、有意义
- 避免使用与标准库相同的包名

```go
package auth
package config
package database
```

**文件命名**:
- 文件名使用小写
- 多个单词使用下划线分隔
- 测试文件以 `_test.go` 结尾

```go
auth.go
auth_test.go
user_model.go
```

**变量命名**:
- 使用驼峰命名法
- 导出变量首字母大写
- 私有变量首字母小写
- 常量使用全大写，单词间用下划线分隔

```go
var UserName string
var userID int
const MAX_RETRY_COUNT = 3
```

**函数命名**:
- 使用驼峰命名法
- 导出函数首字母大写
- 私有函数首字母小写
- 函数名应该动词开头，描述函数功能

```go
func GetUserByID(id int) (*User, error)
func validateUser(user *User) error
func GetConfig() *Config
```

**接口命名**:
- 接口名通常以 `-er` 结尾
- 单方法接口可以只包含方法名

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

#### 1.1.2 代码格式化

使用 `gofmt` 格式化代码:

```bash
gofmt -w .
```

或者使用 `go fmt`:

```bash
go fmt ./...
```

**格式化规则**:
- 使用 tab 缩进，不使用空格
- 每行不超过 120 个字符
- 函数参数过长时换行
- 运算符前后加空格

#### 1.1.3 注释规范

**包注释**:
- 每个包都应该有包注释
- 包注释放在文件开头
- 包注释应该说明包的用途

```go
package auth

// Auth 包提供用户认证和授权功能
//
// 主要功能:
//   - 用户登录验证
//   - 会话管理
//   - 权限验证
//   - RBAC 权限控制
```

**函数注释**:
- 导出函数必须有注释
- 注释说明函数的功能、参数、返回值
- 使用 godoc 格式

```go
// GetUserByID 根据 ID 获取用户信息
//
// 参数:
//   id - 用户 ID
//
// 返回:
//   *User - 用户信息
//   error - 错误信息
func GetUserByID(id int) (*User, error) {
    // 实现代码
}
```

**结构体注释**:
- 导出结构体必须有注释
- 注释说明结构体的用途

```go
// User 表示系统用户
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}
```

**行内注释**:
- 解释复杂的逻辑
- 说明为什么这样做，而不是做什么

```go
// 使用缓存减少数据库查询
if cached, ok := cache.Get(key); ok {
    return cached, nil
}
```

#### 1.1.4 错误处理

**错误定义**:
- 使用 errors.New 创建错误
- 使用 fmt.Errorf 格式化错误
- 使用自定义错误类型

```go
import "errors"

var ErrUserNotFound = errors.New("user not found")

func GetUser(id int) (*User, error) {
    user, err := db.GetUser(id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}
```

**错误处理**:
- 不要忽略错误
- 尽早返回错误
- 使用 if err != nil 检查错误

```go
func ProcessUser(id int) error {
    user, err := GetUser(id)
    if err != nil {
        return err
    }

    if err := ValidateUser(user); err != nil {
        return err
    }

    return SaveUser(user)
}
```

#### 1.1.5 并发安全

**使用互斥锁**:

```go
import "sync"

type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}
```

**使用通道**:

```go
func worker(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func main() {
    ch := make(chan int)
    go worker(ch)

    for value := range ch {
        fmt.Println(value)
    }
}
```

#### 1.1.6 资源管理

**使用 defer 关闭资源**:

```go
func ReadFile(path string) ([]byte, error) {
    file, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    return io.ReadAll(file)
}
```

**使用 defer 释放锁**:

```go
func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}
```

---

### 1.2 项目特定规范

#### 1.2.1 目录结构规范

```
project/
├── adapter/          # 适配器目录
├── plugins/          # 插件目录
├── modules/          # 模块目录
├── context/          # 上下文目录
├── template/         # 模板目录
├── engine/           # 引擎目录
├── tests/            # 测试目录
├── examples/         # 示例目录
├── data/             # 数据目录
├── adm/              # CLI 工具目录
└── build/            # 构建目录
```

#### 1.2.2 模块开发规范

**模块接口**:

```go
package mymodule

import "github.com/purpose168/GoAdmin/modules/service"

// Module 接口定义模块的标准接口
type Module interface {
    Init(services service.List) error
    Name() string
    Version() string
}

// MyModule 实现 Module 接口
type MyModule struct {
    name    string
    version string
}

func (m *MyModule) Init(services service.List) error {
    return nil
}

func (m *MyModule) Name() string {
    return m.name
}

func (m *MyModule) Version() string {
    return m.version
}
```

**模块注册**:

```go
import "github.com/purpose168/GoAdmin/modules/service"

func RegisterModule(name, version string) {
    module := &MyModule{
        name:    name,
        version: version,
    }
    service.Register(name, module)
}
```

#### 1.2.3 插件开发规范

**插件接口**:

```go
package myplugin

import "github.com/purpose168/GoAdmin/plugins"

// Plugin 接口定义插件的标准接口
type Plugin interface {
    InitPlugin(services service.List)
    GetInfo() plugins.Info
    IsInstalled() bool
}

// MyPlugin 实现 Plugin 接口
type MyPlugin struct {
    *plugins.Base
}

func (p *MyPlugin) InitPlugin(services service.List) {
    p.InitBase(services, "myplugin")
    p.initRouter()
}

func (p *MyPlugin) GetInfo() plugins.Info {
    return plugins.Info{
        Title:       "My Plugin",
        Description: "My custom plugin",
        Author:      "me",
        Version:     "1.0.0",
    }
}

func (p *MyPlugin) IsInstalled() bool {
    return true
}
```

**插件注册**:

```go
import "github.com/purpose168/GoAdmin/engine"

func main() {
    eng := engine.Default()
    eng.AddPlugins(myplugin.New())
}
```

#### 1.2.4 适配器开发规范

**适配器接口**:

```go
package myadapter

import "github.com/purpose168/GoAdmin/adapter"

// Adapter 接口定义适配器的标准接口
type Adapter interface {
    Use(app interface{}, routers []adapter.Router) error
    Content(ctx interface{}) *adapter.Context
}

// MyAdapter 实现 Adapter 接口
type MyAdapter struct {
    app interface{}
}

func (a *MyAdapter) Use(app interface{}, routers []adapter.Router) error {
    a.app = app
    return nil
}

func (a *MyAdapter) Content(ctx interface{}) *adapter.Context {
    return &adapter.Context{}
}
```

---

## 2. Git 规范

### 2.1 分支管理

**分支策略**:

```
master (主分支)
  ├── develop (开发分支)
  │   ├── feature/xxx (功能分支)
  │   ├── bugfix/xxx (修复分支)
  │   └── hotfix/xxx (紧急修复分支)
  └── release/xxx (发布分支)
```

**分支说明**:

| 分支类型 | 命名规范 | 用途 |
|---------|---------|------|
| 主分支 | master | 生产环境代码 |
| 开发分支 | develop | 开发环境代码 |
| 功能分支 | feature/功能名 | 开发新功能 |
| 修复分支 | bugfix/问题描述 | 修复 bug |
| 紧急修复 | hotfix/问题描述 | 紧急修复生产问题 |
| 发布分支 | release/版本号 | 准备发布 |

### 2.2 提交规范

**提交信息格式**:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型 (type)**:

| 类型 | 说明 |
|-----|------|
| feat | 新功能 |
| fix | 修复 bug |
| docs | 文档更新 |
| style | 代码格式调整 |
| refactor | 重构代码 |
| perf | 性能优化 |
| test | 测试相关 |
| chore | 构建/工具相关 |

**示例**:

```
feat(auth): add JWT token support

- Add JWT token generation
- Add JWT token validation
- Update auth middleware to support JWT

Closes #123
```

```
fix(database): resolve connection pool issue

Fix the issue where database connections are not properly
released back to the pool.

Fixes #456
```

### 2.3 代码审查

**审查要点**:

1. **代码质量**:
   - 代码是否符合规范
   - 是否有明显的 bug
   - 是否有性能问题

2. **代码可读性**:
   - 变量命名是否清晰
   - 函数是否过于复杂
   - 注释是否充分

3. **代码安全性**:
   - 是否有安全漏洞
   - 输入是否验证
   - 错误是否处理

4. **代码测试**:
   - 是否有单元测试
   - 测试覆盖率是否足够
   - 测试是否通过

**审查流程**:

1. 创建 Pull Request
2. 指定审查人员
3. 审查人员提出意见
4. 开发者修改代码
5. 审查通过后合并

---

## 3. 测试规范

### 3.1 测试分类

**单元测试**:
- 测试单个函数或方法
- 不依赖外部资源
- 快速执行

**集成测试**:
- 测试多个组件的交互
- 可能依赖外部资源
- 执行时间较长

**端到端测试**:
- 测试完整的用户流程
- 模拟真实用户操作
- 执行时间最长

### 3.2 测试编写规范

**测试文件命名**:
- 测试文件以 `_test.go` 结尾
- 测试文件与被测试文件在同一目录

```go
user.go
user_test.go
```

**测试函数命名**:
- 测试函数以 `Test` 开头
- 使用描述性的函数名

```go
func TestGetUserByID(t *testing.T) {
    // 测试代码
}

func TestValidateUser(t *testing.T) {
    // 测试代码
}
```

**测试结构**:

```go
func TestGetUserByID(t *testing.T) {
    tests := []struct {
        name    string
        id      int
        want    *User
        wantErr bool
    }{
        {
            name:    "valid user",
            id:      1,
            want:    &User{ID: 1, Username: "admin"},
            wantErr: false,
        },
        {
            name:    "user not found",
            id:      999,
            want:    nil,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := GetUserByID(tt.id)
            if (err != nil) != tt.wantErr {
                t.Errorf("GetUserByID() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("GetUserByID() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

**使用测试框架**:

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestGetUserByID(t *testing.T) {
    user, err := GetUserByID(1)
    
    require.NoError(t, err)
    assert.NotNil(t, user)
    assert.Equal(t, "admin", user.Username)
}
```

### 3.3 测试覆盖率

**运行测试**:

```bash
# 运行所有测试
go test ./...

# 运行测试并显示覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

**覆盖率要求**:
- 核心代码覆盖率 > 80%
- 一般代码覆盖率 > 60%
- 工具代码覆盖率 > 50%

---

## 4. 文档规范

### 4.1 代码文档

**包文档**:
- 每个包都应该有包文档
- 包文档说明包的用途和主要功能

```go
package auth

// Auth 包提供用户认证和授权功能
//
// 主要功能:
//   - 用户登录验证
//   - 会话管理
//   - 权限验证
//   - RBAC 权限控制
//
// 使用示例:
//
//   import "github.com/purpose168/GoAdmin/modules/auth"
//
//   user, err := auth.Login("admin", "password")
//   if err != nil {
//       return err
//   }
```

**函数文档**:
- 导出函数必须有文档
- 文档说明函数的功能、参数、返回值

```go
// GetUserByID 根据 ID 获取用户信息
//
// 参数:
//   id - 用户 ID
//
// 返回:
//   *User - 用户信息
//   error - 错误信息，如果用户不存在返回 ErrUserNotFound
//
// 示例:
//
//   user, err := auth.GetUserByID(1)
//   if err != nil {
//       return err
//   }
//   fmt.Printf("User: %s\n", user.Username)
func GetUserByID(id int) (*User, error) {
    // 实现代码
}
```

### 4.2 API 文档

**API 文档应该包含**:
- API 端点
- 请求方法
- 请求参数
- 响应格式
- 错误码
- 示例

**示例**:

```markdown
## 获取用户信息

### 请求

```
GET /api/users/:id
```

### 参数

| 参数名 | 类型 | 必填 | 说明 |
|-------|------|------|------|
| id | int | 是 | 用户 ID |

### 响应

成功响应:

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "username": "admin",
    "email": "admin@example.com"
  }
}
```

错误响应:

```json
{
  "code": 1001,
  "message": "user not found"
}
```

### 错误码

| 错误码 | 说明 |
|-------|------|
| 1001 | 用户不存在 |
| 1002 | 参数错误 |
```

### 4.3 README 文档

**README 应该包含**:
- 项目简介
- 功能特性
- 安装说明
- 使用示例
- 配置说明
- 常见问题

**示例**:

```markdown
# GoAdmin

GoAdmin 是一个基于 Go 语言的数据可视化与管理平台构建框架。

## 特性

- 高生产效率
- 插件化架构
- RBAC 认证
- 多框架支持

## 安装

```bash
go get github.com/purpose168/GoAdmin
```

## 使用

```go
import "github.com/purpose168/GoAdmin"

func main() {
    eng := engine.Default()
    eng.AddConfig(&config.Config{...})
    eng.AddPlugins(admin.NewAdmin())
    eng.Use(router)
}
```

## 配置

配置文件示例:

```json
{
  "url_prefix": "/admin",
  "database": {
    "driver": "mysql",
    "host": "localhost",
    "port": "3306"
  }
}
```

## 常见问题

### 如何添加自定义插件？

参考插件开发文档...

## 许可证

Apache-2.0
```

---

## 5. 性能优化规范

### 5.1 数据库优化

**使用索引**:

```go
type User struct {
    ID       int    `xorm:"pk autoincr"`
    Username string `xorm:"unique index"`
    Email    string `xorm:"index"`
}
```

**批量操作**:

```go
// 批量插入
users := []*User{user1, user2, user3}
_, err := engine.Insert(&users)

// 批量更新
_, err := engine.In("id", ids).Update(&User{Status: 1})
```

**使用连接池**:

```go
engine.SetMaxIdleConns(10)
engine.SetMaxOpenConns(100)
engine.SetConnMaxLifetime(time.Hour)
```

### 5.2 缓存优化

**使用缓存**:

```go
func GetUser(id int) (*User, error) {
    // 先从缓存获取
    if cached, ok := cache.Get(fmt.Sprintf("user:%d", id)); ok {
        return cached.(*User), nil
    }

    // 从数据库获取
    user, err := db.GetUser(id)
    if err != nil {
        return nil, err
    }

    // 存入缓存
    cache.Set(fmt.Sprintf("user:%d", id), user, time.Hour)

    return user, nil
}
```

### 5.3 并发优化

**使用协程**:

```go
func ProcessUsers(ids []int) error {
    var wg sync.WaitGroup
    errChan := make(chan error, len(ids))

    for _, id := range ids {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            if err := ProcessUser(id); err != nil {
                errChan <- err
            }
        }(id)
    }

    wg.Wait()
    close(errChan)

    for err := range errChan {
        if err != nil {
            return err
        }
    }

    return nil
}
```

---

## 6. 安全规范

### 6.1 输入验证

**验证用户输入**:

```go
func CreateUser(username, email string) error {
    // 验证用户名
    if len(username) < 3 || len(username) > 20 {
        return errors.New("username length must be between 3 and 20")
    }

    // 验证邮箱
    if !isValidEmail(email) {
        return errors.New("invalid email format")
    }

    // 创建用户
    return db.CreateUser(username, email)
}
```

### 6.2 SQL 注入防护

**使用参数化查询**:

```go
// 错误示例
query := fmt.Sprintf("SELECT * FROM users WHERE id = %s", userID)

// 正确示例
query := "SELECT * FROM users WHERE id = ?"
rows, err := db.Query(query, userID)
```

### 6.3 XSS 防护

**输出转义**:

```go
import "html/template"

func RenderUser(user *User) template.HTML {
    return template.HTML(fmt.Sprintf("<div>%s</div>", template.HTMLEscapeString(user.Username)))
}
```

### 6.4 密码安全

**密码加密**:

```go
import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
    return string(bytes), err
}

func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

---

## 7. 日志规范

### 7.1 日志级别

| 级别 | 用途 |
|-----|------|
| Debug | 调试信息 |
| Info | 一般信息 |
| Warn | 警告信息 |
| Error | 错误信息 |
| Fatal | 致命错误 |

### 7.2 日志格式

**结构化日志**:

```go
logger.Info("User login", logger.Fields{
    "username": "admin",
    "ip":       "127.0.0.1",
    "user_id":  1,
})

logger.Error("Database connection failed", logger.Fields{
    "error": err.Error(),
    "host":   "localhost",
    "port":   3306,
})
```

### 7.3 日志内容

**应该记录**:
- 用户操作
- 错误信息
- 性能指标
- 安全事件

**不应该记录**:
- 敏感信息（密码、token）
- 过于详细的调试信息
- 重复的日志

---

## 8. 版本管理规范

### 8.1 版本号规范

使用语义化版本号 (Semantic Versioning):

```
MAJOR.MINOR.PATCH

例如: 1.2.3
- MAJOR: 主版本号，不兼容的 API 修改
- MINOR: 次版本号，向下兼容的功能性新增
- PATCH: 修订号，向下兼容的问题修正
```

### 8.2 发布流程

1. 更新版本号
2. 更新 CHANGELOG
3. 创建发布分支
4. 测试发布版本
5. 合并到主分支
6. 打标签
7. 发布到仓库

---

## 9. 工具使用

### 9.1 代码检查工具

**golint**:

```bash
# 安装
go install golang.org/x/lint/golint@latest

# 运行
golint ./...
```

**golangci-lint**:

```bash
# 安装
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 运行
golangci-lint run
```

**staticcheck**:

```bash
# 安装
go install honnef.co/go/tools/cmd/staticcheck@latest

# 运行
staticcheck ./...
```

### 9.2 代码格式化工具

**gofmt**:

```bash
gofmt -w .
```

**goimports**:

```bash
# 安装
go install golang.org/x/tools/cmd/goimports@latest

# 运行
goimports -w .
```

### 9.3 依赖管理工具

**go mod**:

```bash
# 整理依赖
go mod tidy

# 验证依赖
go mod verify

# 查看依赖图
go mod graph
```

---

## 10. 最佳实践

### 10.1 代码组织

**按功能组织代码**:

```
package auth

// 认证相关功能
func Login(username, password string) (*User, error)
func Logout(ctx *Context) error
func CheckPermission(user *User, permission string) bool
```

**按层次组织代码**:

```
controller/
  auth_controller.go
  user_controller.go

service/
  auth_service.go
  user_service.go

model/
  user.go
  role.go
```

### 10.2 错误处理

**尽早返回错误**:

```go
func ProcessUser(id int) error {
    user, err := GetUser(id)
    if err != nil {
        return err
    }

    if err := ValidateUser(user); err != nil {
        return err
    }

    return SaveUser(user)
}
```

**包装错误**:

```go
func GetUser(id int) (*User, error) {
    user, err := db.GetUser(id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}
```

### 10.3 资源管理

**使用 defer**:

```go
func ProcessFile(path string) error {
    file, err := os.Open(path)
    if err != nil {
        return err
    }
    defer file.Close()

    return process(file)
}
```

**使用 context**:

```go
func ProcessData(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case data := <-dataChan:
            if err := process(data); err != nil {
                return err
            }
        }
    }
}
```

---

## 11. 总结

GoAdmin 开发规范旨在提高代码质量、可维护性和团队协作效率。遵循这些规范可以:

1. **提高代码质量**: 统一的代码风格和规范
2. **提高可维护性**: 清晰的代码结构和注释
3. **提高团队协作**: 统一的开发流程和工具
4. **减少错误**: 完善的测试和代码审查
5. **提高性能**: 优化的代码和资源管理
6. **增强安全性**: 安全的编码实践

所有开发人员都应该熟悉并遵循这些规范，确保项目的长期健康发展。
